"""
Used MLIL because the stack is seen as variables now which means it becomes a lot easier to do program analysis with for this case.
"""

from binaryninja import *

# Initial state variable(s) to track as tuples (name, version)
INITIAL_STATE_VARS = {('ecx_21', 26), ('eax_10', 11), ('var_1a0', None)}

# Define the target function name or address (e.g., 'sub_10052d48' or 0x10052d48)
TARGET_FUNCTION_NAME = 'command_table_sub_10040746'
TARGET_FUNCTION_ADDRESS = 0x10040746  # Alternatively, use the function name

def get_ssa_gen_set(ssa_block, state_vars):
    gen_set = set()
    for instr in ssa_block:
        if isinstance(instr, MediumLevelILInstruction):
            if instr.operation in [MediumLevelILOperation.MLIL_SET_VAR_SSA, MediumLevelILOperation.MLIL_VAR_PHI]:
                for var in instr.vars_written:
                    if (var.name, var.version) in state_vars or (var.name, None) in state_vars:
                        gen_set.add(instr)
            if instr.operation == MediumLevelILOperation.MLIL_IF:
                # Track conditional reads as well
                for var in instr.vars_read:
                    if (var.name, var.version) in state_vars or (var.name, None) in state_vars:
                        gen_set.add(instr)
    return gen_set

def get_ssa_kill_set(ssa_block, all_defs, state_vars):
    kill_set = set()
    for instr in ssa_block:
        if isinstance(instr, MediumLevelILInstruction):
            if instr.operation in [MediumLevelILOperation.MLIL_SET_VAR_SSA, MediumLevelILOperation.MLIL_VAR_PHI]:
                for var in instr.vars_written:
                    if (var.name, var.version) in state_vars or (var.name, None) in state_vars:
                        for def_instr in all_defs:
                            if def_instr.vars_written and (def_instr.vars_written[0].name, def_instr.vars_written[0].version) == (var.name, var.version) and def_instr != instr:
                                kill_set.add(def_instr)
    return kill_set

def update_state_vars(ssa_block, state_vars):
    new_state_vars = set(state_vars)
    for instr in ssa_block:
        if isinstance(instr, MediumLevelILInstruction):
            if instr.operation in [MediumLevelILOperation.MLIL_SET_VAR_SSA, MediumLevelILOperation.MLIL_VAR_PHI]:
                for var in instr.vars_written:
                    for var_read in instr.vars_read:
                        # Check for SSA variables with versions
                        if hasattr(var_read, 'version'):
                            if (var_read.name, var_read.version) in state_vars or (var_read.name, None) in state_vars:
                                new_state_vars.add((var.name, var.version))
                                print(f"Added {var.name}#{var.version} influenced by {var_read.name}#{var_read.version}")
                        else:
                            if (var_read.name, None) in state_vars:
                                new_state_vars.add((var.name, None))
                                print(f"Added {var.name} influenced by {var_read.name}")
            if instr.operation == MediumLevelILOperation.MLIL_IF:
                for var_read in instr.vars_read:
                    # Check for SSA variables with versions
                    if hasattr(var_read, 'version'):
                        if (var_read.name, var_read.version) in state_vars or (var_read.name, None) in state_vars:
                            new_state_vars.add((var_read.name, var_read.version))
                            print(f"Added {var_read.name}#{var_read.version} from conditional at address {instr.address}")
                    else:
                        if (var_read.name, None) in state_vars:
                            new_state_vars.add((var_read.name, None))
                            print(f"Added {var_read.name} from conditional at address {instr.address}")
    return new_state_vars

def highlight_instructions(target_function, instructions):
    for instr in instructions:
        target_function.set_auto_instr_highlight(instr.address, HighlightStandardColor.RedHighlightColor)

def ssa_data_flow_analysis(bv, target_function):
    # Force the generation of medium level IL
    try:
        _ = target_function.mlil
    except Exception as e:
        print(f"Failed to generate MLIL for function {target_function.name}: {e}")
        return

    # Ensure the function has a medium level IL SSA form
    mlil_ssa = target_function.medium_level_il.ssa_form
    if not mlil_ssa:
        print(f"Function {target_function.name} does not have a valid SSA form.")
        return

    all_defs = set()
    state_vars = set(INITIAL_STATE_VARS)
    highlighted_instructions = set()
    
    for block in mlil_ssa:
        all_defs.update(get_ssa_gen_set(block, state_vars))
    
    block_in_sets = {block: set() for block in mlil_ssa}
    block_out_sets = {block: set() for block in mlil_ssa}

    # Initialize in_set for entry block
    entry_block = mlil_ssa[0]
    block_in_sets[entry_block] = set()

    # Compute in_set and out_set iteratively
    changed = True
    while changed:
        changed = False
        for block in mlil_ssa:
            in_set = set()
            for edge in block.incoming_edges:
                pred_block = edge.source
                in_set.update(block_out_sets[pred_block])
            block_in_sets[block] = in_set

            gen_set = get_ssa_gen_set(block, state_vars)
            kill_set = get_ssa_kill_set(block, all_defs, state_vars)
            out_set = gen_set.union(in_set - kill_set)

            if out_set != block_out_sets[block]:
                block_out_sets[block] = out_set
                changed = True
            
            # Update state variables based on the current block
            new_state_vars = update_state_vars(block, state_vars)
            if new_state_vars != state_vars:
                state_vars = new_state_vars
                changed = True

            # Collect instructions to be highlighted
            highlighted_instructions.update(gen_set)

    # Print the results focusing on state manipulation
    for block in mlil_ssa:
        print(f"Block {block.index} @ {block.start}:\n  gen: {get_ssa_gen_set(block, state_vars)}\n  kill: {get_ssa_kill_set(block, all_defs, state_vars)}\n  in: {block_in_sets[block]}\n  out: {block_out_sets[block]}\n  state_vars: {state_vars}")

    # Highlight the collected instructions
    highlight_instructions(target_function, highlighted_instructions)

# Open the binary and run the analysis
# bv = BinaryViewType.get_view_of_file('path_to_your_binary')
def unset_highlights(function):
    for block in function.medium_level_il:
        for instr in block:
            function.set_auto_instr_highlight(instr.address, bn.enums.HighlightStandardColor.NoHighlightColor)

# Find the target function by name or address
target_function = None
for function in bv.functions:
    if function.name == TARGET_FUNCTION_NAME or function.start == TARGET_FUNCTION_ADDRESS:
        target_function = function
        unset_highlights(function)
        break

if target_function:
    ssa_data_flow_analysis(bv, target_function)
else:
    print(f"Function {TARGET_FUNCTION_NAME} at address {TARGET_FUNCTION_ADDRESS} not found.")
